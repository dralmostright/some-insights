#!/bin/bash
#############################################################
# Author : XXXXXXXXXXXXXX                                  ##
# Company : 		                                   ##
# Description : 					   ##
# 							   ##
# This script is developed for cloining/refresh of         ##
# standby database running in zfs nfs shared mount point   ##
# 							   ##
# Version Control 					   ##
# 		 					   ##
# 		 					   ##
#############################################################

##
## Fundamental Env's
##
#ORACLE_HOME="/u01/app/oracle/product/11.2.0/db_home1"
#ORACLE_SID="ggdbs"

##
## Base Directory for clone log,confs, post sql scripts
##
LOG_BASE_DIR="/home/oracle/scripts/adrci"

##
## User performing the clone
## User other than [oracle] performing clone will halt
## the execution of script
##
PURGE_USER=`whoami`

##
## Logfile for clone
##
PURGE_LOG_FILE=${LOG_BASE_DIR}/log/alertPURGE.log

##
##
##
DATE_TIME=`date -d now`
PURGE_DT_FORMAT=`date +"%Y_%m_%d_%H_%M_%S"`

##
## Purge Error
##
PURGE_ORA_ERROR='ORA 600'
PURGE_INCIDENTS=""

##
## Env for locating full path of the script being executed
##
#CURSCRIPT=`realpath $0`
CURSCRIPT=`readlink -f $0`

##
## ADR home
##
ADRHOME=""
ADRBASE=""

##
## Default Error Message
##
PURGE_ERR="==> Error during running script..\n===> ${CURSCRIPT}\n====> Sorry Something went wrong...\n=====> while running scripts...."

##
## Default Info Message
##
PURGE_MSG="==> Info generated by script....\n===> ${CURSCRIPT}\n====> Purge in progress.... \n=====>Please wait......."

##
## For Warning and Text manupulation
##
bold=$(tput bold)
reset=$(tput sgr0)
bell=$(tput bel)
underline=$(tput smul)

#############################################################
# Functions to handle exceptions and erros                  #
#############################################################

##
## Array to hold messages
## First Element of array is always Error/Info header
## Remaning are details with supplimentary messages
##
declare -a CLONEMSG

##
## Format output
##
## Whenever CLONEMSG is of zero length default error/info message is reported
##
FunFormatOutput(){
echo ""
echo "+-------------------------------------------------------+"
if [ ${#CLONEMSG[@]} -eq 0 ]
  then
	  echo -e "${1}"
else
    if [ ${CLONEMSG[0]} = "E" ]
    then
       echo -e "==> Error during running script..... \n===> $CURSCRIPT"
    else
       echo -e "==> Info generated by script....\n===> ${CURSCRIPT}"
    fi
    arowmarker="===="
    for (( i=1; i<${#CLONEMSG[@]}; i++ ))
      do 
	echo "${arowmarker}> ${CLONEMSG[$i]}..."
	if [ -z ${2} ]
	  then
             arowmarker=${arowmarker}"="
        fi
      done
fi
echo "+-------------------------------------------------------+" 
}

##
## Function to redirect output 
## Function also determine to moveahead or halt as per input {$2} value
## 1 for stop execution and other to continue
##
FunReportOutput(){
if [ "${2}" = "B" ]
  then
     FunFormatOutput "${1}"
     FunFormatOutput "${1}" >> ${PURGE_LOG_FILE}
elif [ "${2}" = "L" ]
    then
	   FunFormatOutput "${1}" >> ${PURGE_LOG_FILE}
elif [ "${2}" = "BI" ]
  then
     FunFormatOutput "${1}" "Y"
     FunFormatOutput "${1}" "Y" >> ${PURGE_LOG_FILE}
else
    FunFormatOutput "${1}"
fi

if [ ! -z ${3} ]
  then
    exit 1;
fi
}

##
## Verify message from other programs
## 1 : message to search in
## 2 : String to be searched
## 3 : Threshed to govern script execution
## 4 : Provide info only without halting execution
##
FunVerifyError(){
errorCount=`echo ${1} |grep  ${2}|grep -v grep|wc -l`
CLONEMSG=()
if test ${errorCount} -ge ${3}
then
   if [ -z ${4} ]
    then
       FunReportOutput "${1}" "B" "A"
    else
       FunReportOutput "${1} ${4}" "B"
    fi
else
   FunReportOutput "${1}" "B"
fi
}

##
## Function to verify if file exists
##
FunVerifyDirectory(){
     if [ ! -f ${1} ]
	then
           echo 1;
     else
        echo 0;
     fi
}

##
## Function to verify directory and/or file existence
## D|d to check validness for directory
## F|f to check validness for file
##
FunVerifyDirFile(){
case ${1} in
    D|d )
    if [ ! -d ${2} ]
        then
           echo 1;
    else 
       echo 0; 
    fi
    ;;
	
    f|F )
    if [ ! -f ${2} ]
	then
	   echo 1;
    else
       echo 0;
    fi
    ;;
	
    * )
       echo 2; 
    ;;
esac
}

##
## Function to check valid oracle sid
## ${1} array holding the ORACLE_SID's
## ${2} string to check it it exixts in ${1}
##
FunCheckSidValid(){
   param1=("${!1}")
   check=${2}  
   statusSID=0
      for i in ${param1[@]}
	do
	  if [ ${i} == $2 ];
	    then
		statusSID=1
	    break
	  esle
             echo $i; 
	   fi 
        done
    return $statusSID;
}

##
## Function rotate file
##
FunRotateFile(){
if [ `FunVerifyDirFile "F" ${LOG_BASE_DIR}/diag/${1}` = "1" ]
  then
     mv ${LOG_BASE_DIR}/log/${1} ${LOG_BASE_DIR}/log/${1}_${PURGE_DT_FORMAT}
     touch ${LOG_BASE_DIR}/log/${1}
else
   touch ${LOG_BASE_DIR}/log/${1}
fi
}


##
## Get Oracle SID env 
## Will list all the oracle instances running on the box..
## ASM instance will be excluded 
##
FunGetOracleSID(){
myarr=($(ps -ef | grep ora_smon|grep -v asm_ |  grep -v grep | awk -F' ' '{print $NF}' | cut -c 10-))
FunCheckSidValid myarr[@] ${1}
if [ $? -eq 0 ]
  then
     CLONEMSG=('E' "ENV ORACLE_SID verification Failed" "No DB instance with ORACLE_SID : ${1} running" "Env is invalid. Aborting  " "Please try again fixing above err message")
      if [ -z ${2} ]
      then
         CLONEMSG=('E' "ENV ORACLE_SID verification Failed" "No DB instance with ORACLE_SID : ${1} running" "Env is invalid. Program will continue")
         FunReportOutput "ORACLESID" "B"
      else
         FunReportOutput "ORACLESID" "B" "A"
      fi
fi
CLONEMSG=('I' "ENV ORACLE_SID verification Passed" "DB instance with ORACLE_SID : ${1} found running")
FunReportOutput "ORACLESID" "B"
}



##
## Get the ADR home for provided instance...
##
FunGetADRhome(){
ADRHOME=$($1/bin/sqlplus -s /nolog <<END
set pagesize 0 feedback off verify off echo off;
connect / as sysdba
select value from v\$diag_info where name='ADR Home';
END
)
}

##
## Get the ADR base for provided instance...
##
FunGetADRBASE(){
ADRBASE=$($1/bin/sqlplus -s /nolog <<END
set pagesize 0 feedback off verify off echo off;
connect / as sysdba
select value from v\$diag_info where name='ADR Base';
END
)
}


##
## Fun to get Oracle Instance running on Box.
##

FunListOraInstance(){
echo "+-------------------------------------------------------+"
echo "| Starting  purging of ORA-700 ..............            "
echo "+-------------------------------------------------------+"
echo ""
echo "==> Purge Start Time: `date -d now`"
echo ""
echo "+-------------------------------------------------------+"
myarr=($(ps -ef | grep ora_smon | grep -v asm_ | grep -v grep| awk -F' ' '{print $NF}' | cut -c 10-))
echo "==> DB Instances running on box: `hostname`"
for i in "${myarr[@]}"
  do :
   echo "===> "$i 
  done
echo "+-------------------------------------------------------+"
}


##
## Funtion to get incidents
##
FunGetINCIDENTS(){
PURGE_INCIDENTS=$($1/bin/adrci <<END
set base ${ADRBASE}
set home ${ADRHOME}
show incidents -all
END
)
}

##
## Funtion to delete incidents
##
FunDelINCIDENTS(){
PURGE_INCIDENTS=$($1/bin/adrci <<END
set base ${ADRBASE}
set home ${ADRHOME}
@${LOG_BASE_DIR}/log/${2}
END
)
}

##
## Select provided Ora errors
##
FunGETPURGEScript(){
FunRotateFile "deleteORA700.adr"
echo -e "${1}" | sed '/ADRCI/,/CREATE_TIME/d;$d;/rows fetched/,/ /d;/^$/d' | grep "${2}" | sed 's/^/purge -i /g;s/ORA.*//g' > ${LOG_BASE_DIR}/log/deleteORA700.adr
}



##
##
##
#export ORACLE_HOME
#export ORACLE_SID
#FunListOraInstance
#FunRotateFile "alertPURGE.log"
#FunListOraInstance >> ${PURGE_LOG_FILE}


##
## Check Envs
##
if [ -z ${1} ]
   then
      CLONEMSG=('I' "No value passed for Oracle SID " "Default value file will be used")
      FunReportOutput "ORACLESID" "B"
else
    ORACLE_SID=${1}
fi

if [ ! "${2}" = "" ]
then
PURGE_ORA_ERROR="${2}"
fi

if [ "${ORACLE_SID}" = "" ] || [ "${PURGE_ORA_ERROR}" = "" ]
 then
    CLONEMSG=('E' "Some parameters found Empty " "Program execution will halt")
    FunReportOutput "ORACLESID" "B" "A"
fi



##
##
##
export ORACLE_SID
export ORAENV_ASK=NO;
export PATH=$PATH:/u01/app/oracle/product/11.2.0/db_home1/bin
. oraenv

echo $ORACLE_SID
echo $ORACLE_HOME
#export ORACLE_HOME
#export ORACLE_SID
FunListOraInstance
FunRotateFile "alertPURGE.log"
FunListOraInstance >> ${PURGE_LOG_FILE}



##
##
##
FunGetOracleSID ${ORACLE_SID} "A"
FunGetADRhome ${ORACLE_HOME}
FunGetADRBASE ${ORACLE_HOME}

CLONEMSG=('I' "Fetching incidents for " "DB instance with ORACLE_SID : ${ORACLE_SID} " "ADR BASE : ${ADRBASE}" "ADR HOME : ${ADRHOME} ")
FunReportOutput "ORACLESID" "B"

temphome=`echo ${ADRHOME} | sed "s:${ADRBASE}::;s:^/::"`
ADRHOME=$temphome

FunGetINCIDENTS $ORACLE_HOME
CLONEMSG=()
FunReportOutput "Overall incidents \n=================\n${PURGE_INCIDENTS}" "B"
FunGETPURGEScript "${PURGE_INCIDENTS}" "${PURGE_ORA_ERROR}"
CLONEMSG=()
FunReportOutput "Incidents to be purged with ORA-ERR : ${PURGE_ORA_ERROR}\n================================================\n`cat ${LOG_BASE_DIR}/log/deleteORA700.adr | awk '{ print "Incidents number :" $3 }'`" "B"
#FunReportOutput "Incidents to be purged with ORA-ERR : ${PURGE_ORA_ERROR}\n================================================\n" "B"
FunDelINCIDENTS $ORACLE_HOME "deleteORA700.adr"

CLONEMSG=('I' "Deleting of incidents for " "DB instance with ORACLE_SID : ${ORACLE_SID} " "ADR BASE : ${ADRBASE}" "ADR HOME : ${ADRHOME} " "Completed... ")
FunReportOutput "ORACLESID" "B"

CLONEMSG=('I' "Completed Time : `date -d now`")
FunReportOutput "ORACLESID" "B"
cat log/alertPURGE.log | mail -s "$(echo -e "Release Status [Green]\nContent-Type: text/html")" uev62393@cndps.com 

